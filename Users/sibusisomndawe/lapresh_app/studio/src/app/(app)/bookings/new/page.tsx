
"use client";

import { useState, useEffect } from "react";
import { PageHeader } from "@/components/shared/PageHeader";
import { BookingForm, type BookingFormValues } from "@/components/forms/BookingForm";
import type { Salon, Hairdresser, User, BookingDoc, LocationDoc, HairdresserDoc } from "@/lib/types";
import { PlusCircle, Loader2 } from "lucide-react";
import { toast } from "@/hooks/use-toast";
import { useRouter } from 'next/navigation';
import { useAuth } from "@/contexts/AuthContext";
import { db, collection, addDoc, getDocs, serverTimestamp, Timestamp } from "@/lib/firebase";

async function createBookingInFirestore(data: BookingFormValues, currentUser: User | null): Promise<string> {
  console.log("[createBookingInFirestore] Attempting to create booking. Form data:", data);
  console.log("[createBookingInFirestore] Current user:", currentUser);

  if (!currentUser) {
    console.error("[createBookingInFirestore] No current user available. Aborting.");
    toast({
      title: "Authentication Error",
      description: "You must be logged in to create a booking. Please refresh and log in again.",
      variant: "destructive"
    });
    throw new Error("User not authenticated. Cannot create booking.");
  }

  // data.appointmentDateTime from BookingForm is already the combined Date object
  const appointmentDateForFirestore = Timestamp.fromDate(data.appointmentDateTime);
  console.log("[createBookingInFirestore] Converted appointmentDateTime to Firestore Timestamp:", appointmentDateForFirestore);

  const newBookingDoc: Omit<BookingDoc, 'id'> = { // 'id' is auto-generated by Firestore
    clientName: data.clientName,
    clientEmail: data.clientEmail || "",
    clientPhone: data.clientPhone,
    salonId: data.salonId,
    hairdresserId: data.hairdresserId,
    service: data.service,
    appointmentDateTime: appointmentDateForFirestore,
    durationMinutes: data.durationMinutes,
    status: 'Confirmed',
    notes: data.notes || "",
    // color is optional in BookingDoc, will be omitted if not present in data
    createdAt: serverTimestamp() as Timestamp,
    updatedAt: serverTimestamp() as Timestamp,
  };
  console.log("[createBookingInFirestore] Prepared Firestore document data:", newBookingDoc);

  try {
    console.log("[createBookingInFirestore] Calling addDoc to 'bookings' collection with db instance:", db);
    const docRef = await addDoc(collection(db, "bookings"), newBookingDoc);
    console.log("[createBookingInFirestore] Successfully created booking with Firestore ID:", docRef.id);
    toast({ title: "Booking Created", description: `Appointment for ${data.clientName} has been successfully scheduled.` });
    return docRef.id;
  } catch (error: any) {
    console.error("[createBookingInFirestore] Error writing document to Firestore:", error);
    // Attempt to stringify the error to get more details, but be cautious with large objects
    try {
      console.error("[createBookingInFirestore] Full error object stringified:", JSON.stringify(error, Object.getOwnPropertyNames(error)));
    } catch (stringifyError) {
      console.error("[createBookingInFirestore] Could not stringify the full error object:", stringifyError);
    }
    toast({
      title: "Booking Creation Failed",
      description: `Could not save booking to database. Error: ${error.message || 'Unknown error'}. Please check browser console for more details.`,
      variant: "destructive"
    });
    throw error; // Re-throw the error so the calling function knows it failed
  }
}


export default function NewBookingPage() {
  const { user } = useAuth();
  const [salons, setSalons] = useState<Salon[]>([]);
  const [hairdressers, setHairdressers] = useState<Hairdresser[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const router = useRouter();
  const [initialFormValues, setInitialFormValues] = useState<Partial<BookingFormValues>>({});


  useEffect(() => {
    console.log("[NewBookingPage] useEffect triggered. Auth User object:", user);
    if (!user) {
      console.log("[NewBookingPage] No user authenticated, data fetching will be skipped by form logic or this effect if guarded.");
      setIsLoading(false); // Allow form to render, it might handle no user appropriately or AppLayout will redirect
      return;
    }

    const fetchData = async () => {
      console.log("[NewBookingPage] fetchData started.");
      setIsLoading(true);
      try {
        console.log("[NewBookingPage] Fetching salons...");
        const locationsCol = collection(db, "locations");
        const locationSnapshot = await getDocs(locationsCol);
        const salonsList = locationSnapshot.docs.map(sDoc => ({
          id: sDoc.id,
          ...(sDoc.data() as LocationDoc)
        } as Salon));
        console.log(`[NewBookingPage] Fetched ${salonsList.length} salons:`, salonsList);
        setSalons(salonsList);

        console.log("[NewBookingPage] Fetching hairdressers...");
        const hairdressersCol = collection(db, "hairdressers");
        const hairdresserSnapshot = await getDocs(hairdressersCol);
        console.log(`[NewBookingPage] Hairdresser snapshot has ${hairdresserSnapshot.docs.length} documents.`);

        const hairdressersList = hairdresserSnapshot.docs.map(hDoc => {
          const data = hDoc.data() as HairdresserDoc;
          console.log(`[NewBookingPage] Mapping hairdresser doc ${hDoc.id}:`, data);
          return {
            id: hDoc.id,
            userId: data.user_id,
            name: data.name,
            email: data.email,
            assigned_locations: data.assigned_locations || [],
            specialties: data.specialties || [],
            availability: data.availability || "",
            working_days: data.working_days || [],
            profilePictureUrl: data.profilePictureUrl || "",
            must_reset_password: data.must_reset_password || false,
            createdAt: data.createdAt,
            updatedAt: data.updatedAt,
          } as Hairdresser;
        });
        console.log(`[NewBookingPage] Mapped ${hairdressersList.length} hairdressers:`, hairdressersList);
        setHairdressers(hairdressersList);

        const prefillValues: Partial<BookingFormValues> = {};
        if (user?.role === 'hairdresser' && user.hairdresserProfileId) {
            console.log("[NewBookingPage] User is hairdresser, attempting to prefill form.");
            prefillValues.hairdresserId = user.hairdresserProfileId;
            const hairdresserDetails = hairdressersList.find(h => h.id === user.hairdresserProfileId);
            if (hairdresserDetails && hairdresserDetails.assigned_locations.length > 0) {
                prefillValues.salonId = hairdresserDetails.assigned_locations[0];
                console.log("[NewBookingPage] Prefilling salonId:", hairdresserDetails.assigned_locations[0]);
            }
            console.log("[NewBookingPage] Prefill values for hairdresser:", prefillValues);
        }
        setInitialFormValues(prefillValues);

      } catch (error: any) {
        console.error("[NewBookingPage] Error fetching data for new booking:", error);
        toast({ title: "Error Loading Data", description: `Could not load required data: ${error.message}. Check console for details.`, variant: "destructive" });
      } finally {
        console.log("[NewBookingPage] fetchData finished.");
        setIsLoading(false);
      }
    };

    fetchData();
  }, [user]);

  const handleCreateBooking = async (data: BookingFormValues) => {
    console.log("[handleCreateBooking] Starting booking creation process with form data:", data);
    console.log("[handleCreateBooking] Current auth user from useAuth():", user);

    if (!user) {
        console.error("[handleCreateBooking] Critical: No user object available from useAuth() hook. Cannot proceed with booking creation.");
        toast({
            title: "Authentication Error",
            description: "Cannot create booking: User is not authenticated. Please log in again.",
            variant: "destructive",
        });
        setIsSubmitting(false); // Ensure submission state is reset
        return;
    }

    setIsSubmitting(true);
    try {
      await createBookingInFirestore(data, user);
      console.log("[handleCreateBooking] Booking creation reported as successful, navigating...");
      router.push(user?.role === 'hairdresser' ? '/bookings?view=mine' : '/bookings');
    } catch (error) {
      console.error("[handleCreateBooking] Failed to create booking (error caught from createBookingInFirestore):", error);
      // Toast for error is handled by createBookingInFirestore, but good to log here too.
      // If the error was "User not authenticated", it's handled by createBookingInFirestore now.
    } finally {
      console.log("[handleCreateBooking] Booking creation process finished.");
      setIsSubmitting(false);
    }
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-full">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
        <span className="ml-2">Loading booking form...</span>
      </div>
    );
  }

  // This check might be too early if user object is still loading. Relies on AppLayout for primary auth guard.
  // if (!user && !isLoading) {
  //   return (
  //       <div className="flex justify-center items-center h-full">
  //           <p className="text-muted-foreground">Please log in to create a booking. Redirecting...</p>
  //       </div>
  //   );
  // }

  return (
    <div className="space-y-8">
      <PageHeader
        title="New Booking"
        description="Schedule a new appointment for a client."
        icon={PlusCircle}
      />
      <BookingForm
        salons={salons}
        allHairdressers={hairdressers}
        onSubmit={handleCreateBooking}
        initialDataPreselected={initialFormValues}
        isSubmitting={isSubmitting}
      />
    </div>
  );
}
